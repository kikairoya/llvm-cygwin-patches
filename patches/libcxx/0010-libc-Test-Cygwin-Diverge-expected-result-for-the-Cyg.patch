From 65f240ae3ba1d91d3662a901467960111f643729 Mon Sep 17 00:00:00 2001
From: kikairoya <kikairoya@gmail.com>
Date: Sat, 7 Jun 2025 17:53:50 +0900
Subject: [PATCH 10/15] [libc++][Test][Cygwin] Diverge expected result for the
 Cygwin target (part 3/5 - memory management)

---
 libcxx/test/libcxx/memory/trivial_abi/weak_ptr_ret.pass.cpp    | 2 +-
 .../depr.c.headers/stdlib_h.aligned_alloc.compile.pass.cpp     | 2 +-
 .../new.delete.array/new.size_align.replace.indirect.pass.cpp  | 3 +++
 .../new.size_align_nothrow.replace.indirect.pass.cpp           | 3 +++
 .../new.delete.single/delete_align_val_t_replace.pass.cpp      | 3 +++
 .../new.delete.single/new.size_align.replace.pass.cpp          | 3 +++
 .../new.size_align_nothrow.replace.indirect.pass.cpp           | 3 +++
 .../new.delete.single/new.size_align_nothrow.replace.pass.cpp  | 3 +++
 .../support.runtime/cstdlib.aligned_alloc.compile.pass.cpp     | 2 +-
 .../default.allocator/allocator.members/allocate.pass.cpp      | 3 +++
 .../allocator.members/allocate_at_least.pass.cpp               | 3 +++
 .../meta/meta.trans/meta.trans.other/aligned_storage.pass.cpp  | 2 +-
 .../allocate_overaligned_request.pass.cpp                      | 3 +++
 .../sync_allocate_overaligned_request.pass.cpp                 | 3 +++
 .../unsync_allocate_overaligned_request.pass.cpp               | 3 +++
 15 files changed, 37 insertions(+), 4 deletions(-)

diff --git a/libcxx/test/libcxx/memory/trivial_abi/weak_ptr_ret.pass.cpp b/libcxx/test/libcxx/memory/trivial_abi/weak_ptr_ret.pass.cpp
index 0b1a434ee45b..721dbec03095 100644
--- a/libcxx/test/libcxx/memory/trivial_abi/weak_ptr_ret.pass.cpp
+++ b/libcxx/test/libcxx/memory/trivial_abi/weak_ptr_ret.pass.cpp
@@ -50,7 +50,7 @@ int main(int, char**) {
   //
   // With trivial_abi, local_addr is the address of a local variable in
   // make_val, and hence different from &ret.
-#if !defined(__i386__) && !defined(__arm__) && !defined(_WIN32) && !defined(_AIX)
+#if !defined(__i386__) && !defined(__arm__) && !defined(_WIN32) && !defined(__CYGWIN__) && !defined(_AIX)
   // On X86, structs are never returned in registers.
   // On AIX, structs are never returned in registers.
   // On ARM32, structs larger than 4 bytes cannot be returned in registers.
diff --git a/libcxx/test/std/depr/depr.c.headers/stdlib_h.aligned_alloc.compile.pass.cpp b/libcxx/test/std/depr/depr.c.headers/stdlib_h.aligned_alloc.compile.pass.cpp
index aec2c7f98af7..6be1b2c0d52f 100644
--- a/libcxx/test/std/depr/depr.c.headers/stdlib_h.aligned_alloc.compile.pass.cpp
+++ b/libcxx/test/std/depr/depr.c.headers/stdlib_h.aligned_alloc.compile.pass.cpp
@@ -16,7 +16,7 @@
 // XFAIL: target={{.+}}-apple-macosx10.{{(13|14)(.0)?}}
 
 // ::aligned_alloc is not implemented on Windows
-// XFAIL: target={{.+}}-windows-{{.+}}
+// XFAIL: target={{.+}}-windows-{{.+}} && !cygwin
 
 // ::aligned_alloc is available starting with Android P (API 28)
 // XFAIL: target={{.+}}-android{{(eabi)?(21|22|23|24|25|26|27)}}
diff --git a/libcxx/test/std/language.support/support.dynamic/new.delete/new.delete.array/new.size_align.replace.indirect.pass.cpp b/libcxx/test/std/language.support/support.dynamic/new.delete/new.delete.array/new.size_align.replace.indirect.pass.cpp
index 3d9856e0b1ba..0db17279c8ed 100644
--- a/libcxx/test/std/language.support/support.dynamic/new.delete/new.delete.array/new.size_align.replace.indirect.pass.cpp
+++ b/libcxx/test/std/language.support/support.dynamic/new.delete/new.delete.array/new.size_align.replace.indirect.pass.cpp
@@ -15,6 +15,9 @@
 
 // XFAIL: LIBCXX-AIX-FIXME
 
+// Cygwin runtime has hack to able override operator-new defined in DLL from EXE but it don't works for align_val_t overloads.
+// XFAIL: cygwin
+
 // Libc++ when built for z/OS doesn't contain the aligned allocation functions,
 // nor does the dynamic library shipped with z/OS.
 // XFAIL: target={{.+}}-zos{{.*}}
diff --git a/libcxx/test/std/language.support/support.dynamic/new.delete/new.delete.array/new.size_align_nothrow.replace.indirect.pass.cpp b/libcxx/test/std/language.support/support.dynamic/new.delete/new.delete.array/new.size_align_nothrow.replace.indirect.pass.cpp
index c9dc20a34b13..7feaab2c360e 100644
--- a/libcxx/test/std/language.support/support.dynamic/new.delete/new.delete.array/new.size_align_nothrow.replace.indirect.pass.cpp
+++ b/libcxx/test/std/language.support/support.dynamic/new.delete/new.delete.array/new.size_align_nothrow.replace.indirect.pass.cpp
@@ -20,6 +20,9 @@
 
 // XFAIL: LIBCXX-AIX-FIXME
 
+// Cygwin runtime has hack to able override operator-new defined in DLL from EXE but it don't works for align_val_t overloads.
+// XFAIL: cygwin
+
 // Libc++ when built for z/OS doesn't contain the aligned allocation functions,
 // nor does the dynamic library shipped with z/OS.
 // XFAIL: target={{.+}}-zos{{.*}}
diff --git a/libcxx/test/std/language.support/support.dynamic/new.delete/new.delete.single/delete_align_val_t_replace.pass.cpp b/libcxx/test/std/language.support/support.dynamic/new.delete/new.delete.single/delete_align_val_t_replace.pass.cpp
index c346c42f157b..f863617cd3ec 100644
--- a/libcxx/test/std/language.support/support.dynamic/new.delete/new.delete.single/delete_align_val_t_replace.pass.cpp
+++ b/libcxx/test/std/language.support/support.dynamic/new.delete/new.delete.single/delete_align_val_t_replace.pass.cpp
@@ -10,6 +10,9 @@
 
 // UNSUPPORTED: sanitizer-new-delete, c++03, c++11, c++14
 
+// Cygwin runtime has hack to able override operator-new defined in DLL from EXE but it don't works for align_val_t overloads.
+// XFAIL: cygwin
+
 // Libc++ when built for z/OS doesn't contain the aligned allocation functions,
 // nor does the dynamic library shipped with z/OS.
 // XFAIL: target={{.+}}-zos{{.*}}
diff --git a/libcxx/test/std/language.support/support.dynamic/new.delete/new.delete.single/new.size_align.replace.pass.cpp b/libcxx/test/std/language.support/support.dynamic/new.delete/new.delete.single/new.size_align.replace.pass.cpp
index f9e339b22190..c3d18ac58e06 100644
--- a/libcxx/test/std/language.support/support.dynamic/new.delete/new.delete.single/new.size_align.replace.pass.cpp
+++ b/libcxx/test/std/language.support/support.dynamic/new.delete/new.delete.single/new.size_align.replace.pass.cpp
@@ -10,6 +10,9 @@
 
 // Test that we can replace the operator by defining our own.
 
+// Cygwin runtime has hack to able override operator-new defined in DLL from EXE but it don't works for align_val_t overloads.
+// XFAIL: cygwin
+
 // UNSUPPORTED: c++03, c++11, c++14
 // UNSUPPORTED: sanitizer-new-delete
 
diff --git a/libcxx/test/std/language.support/support.dynamic/new.delete/new.delete.single/new.size_align_nothrow.replace.indirect.pass.cpp b/libcxx/test/std/language.support/support.dynamic/new.delete/new.delete.single/new.size_align_nothrow.replace.indirect.pass.cpp
index dedd3089f5ab..0877408bd826 100644
--- a/libcxx/test/std/language.support/support.dynamic/new.delete/new.delete.single/new.size_align_nothrow.replace.indirect.pass.cpp
+++ b/libcxx/test/std/language.support/support.dynamic/new.delete/new.delete.single/new.size_align_nothrow.replace.indirect.pass.cpp
@@ -19,6 +19,9 @@
 
 // XFAIL: LIBCXX-AIX-FIXME
 
+// Cygwin runtime has hack to able override operator-new defined in DLL from EXE but it don't works for align_val_t overloads.
+// XFAIL: cygwin
+
 // Libc++ when built for z/OS doesn't contain the aligned allocation functions,
 // nor does the dynamic library shipped with z/OS.
 // XFAIL: target={{.+}}-zos{{.*}}
diff --git a/libcxx/test/std/language.support/support.dynamic/new.delete/new.delete.single/new.size_align_nothrow.replace.pass.cpp b/libcxx/test/std/language.support/support.dynamic/new.delete/new.delete.single/new.size_align_nothrow.replace.pass.cpp
index a25b67ea554b..d84e8f60c949 100644
--- a/libcxx/test/std/language.support/support.dynamic/new.delete/new.delete.single/new.size_align_nothrow.replace.pass.cpp
+++ b/libcxx/test/std/language.support/support.dynamic/new.delete/new.delete.single/new.size_align_nothrow.replace.pass.cpp
@@ -13,6 +13,9 @@
 // UNSUPPORTED: c++03, c++11, c++14
 // UNSUPPORTED: sanitizer-new-delete
 
+// Cygwin runtime has hack to able override operator-new defined in DLL from EXE but it don't works for align_val_t overloads.
+// XFAIL: cygwin
+
 // Libc++ when built for z/OS doesn't contain the aligned allocation functions,
 // nor does the dynamic library shipped with z/OS.
 // XFAIL: target={{.+}}-zos{{.*}}
diff --git a/libcxx/test/std/language.support/support.runtime/cstdlib.aligned_alloc.compile.pass.cpp b/libcxx/test/std/language.support/support.runtime/cstdlib.aligned_alloc.compile.pass.cpp
index 67eef7da413b..746f21839a27 100644
--- a/libcxx/test/std/language.support/support.runtime/cstdlib.aligned_alloc.compile.pass.cpp
+++ b/libcxx/test/std/language.support/support.runtime/cstdlib.aligned_alloc.compile.pass.cpp
@@ -16,7 +16,7 @@
 // XFAIL: target={{.+}}-apple-macosx10.{{13|14}}
 
 // ::aligned_alloc is not implemented on Windows
-// XFAIL: target={{.+}}-windows-{{.+}}
+// XFAIL: target={{.+}}-windows-{{.+}} && !cygwin
 
 // ::aligned_alloc is available starting with Android P (API 28)
 // XFAIL: target={{.+}}-android{{(eabi)?(21|22|23|24|25|26|27)}}
diff --git a/libcxx/test/std/utilities/memory/default.allocator/allocator.members/allocate.pass.cpp b/libcxx/test/std/utilities/memory/default.allocator/allocator.members/allocate.pass.cpp
index 244e9800d0a1..1eeb2c34deab 100644
--- a/libcxx/test/std/utilities/memory/default.allocator/allocator.members/allocate.pass.cpp
+++ b/libcxx/test/std/utilities/memory/default.allocator/allocator.members/allocate.pass.cpp
@@ -6,6 +6,9 @@
 //
 //===----------------------------------------------------------------------===//
 
+// Cygwin runtime has hack to able override operator-new defined in DLL from EXE but it don't works for align_val_t overloads.
+// XFAIL: cygwin
+
 // <memory>
 
 // allocator:
diff --git a/libcxx/test/std/utilities/memory/default.allocator/allocator.members/allocate_at_least.pass.cpp b/libcxx/test/std/utilities/memory/default.allocator/allocator.members/allocate_at_least.pass.cpp
index 05c66b065ef1..46a324b20f80 100644
--- a/libcxx/test/std/utilities/memory/default.allocator/allocator.members/allocate_at_least.pass.cpp
+++ b/libcxx/test/std/utilities/memory/default.allocator/allocator.members/allocate_at_least.pass.cpp
@@ -8,6 +8,9 @@
 
 // UNSUPPORTED: c++03, c++11, c++14, c++17, c++20
 
+// Cygwin runtime has hack to able override operator-new defined in DLL from EXE but it don't works for align_val_t overloads.
+// XFAIL: cygwin
+
 // <memory>
 
 // allocation_result<T*> allocate_at_least(size_t n)
diff --git a/libcxx/test/std/utilities/meta/meta.trans/meta.trans.other/aligned_storage.pass.cpp b/libcxx/test/std/utilities/meta/meta.trans/meta.trans.other/aligned_storage.pass.cpp
index 79b9294b7418..b21c54d04ab0 100644
--- a/libcxx/test/std/utilities/meta/meta.trans/meta.trans.other/aligned_storage.pass.cpp
+++ b/libcxx/test/std/utilities/meta/meta.trans/meta.trans.other/aligned_storage.pass.cpp
@@ -343,7 +343,7 @@ int main(int, char**)
     static_assert(std::alignment_of<T1>::value == Align, "");
     static_assert(sizeof(T1) == Align, "");
   }
-#ifndef _WIN32
+#if !defined(_WIN32) && !defined(__CYGWIN__)
   // Windows only supports alignment up to 8192 bytes.
   {
     const int Align = 65536;
diff --git a/libcxx/test/std/utilities/utility/mem.res/mem.res.monotonic.buffer/mem.res.monotonic.buffer.mem/allocate_overaligned_request.pass.cpp b/libcxx/test/std/utilities/utility/mem.res/mem.res.monotonic.buffer/mem.res.monotonic.buffer.mem/allocate_overaligned_request.pass.cpp
index 95c6b36b71f9..bde00209013d 100644
--- a/libcxx/test/std/utilities/utility/mem.res/mem.res.monotonic.buffer/mem.res.monotonic.buffer.mem/allocate_overaligned_request.pass.cpp
+++ b/libcxx/test/std/utilities/utility/mem.res/mem.res.monotonic.buffer/mem.res.monotonic.buffer.mem/allocate_overaligned_request.pass.cpp
@@ -10,6 +10,9 @@
 // TODO: Change to XFAIL once https://llvm.org/PR40995 is fixed
 // UNSUPPORTED: availability-pmr-missing
 
+// Cygwin runtime has hack to able override operator-new defined in DLL from EXE but it don't works for align_val_t overloads.
+// XFAIL: cygwin
+
 // <memory_resource>
 
 // class monotonic_buffer_resource
diff --git a/libcxx/test/std/utilities/utility/mem.res/mem.res.pool/mem.res.pool.mem/sync_allocate_overaligned_request.pass.cpp b/libcxx/test/std/utilities/utility/mem.res/mem.res.pool/mem.res.pool.mem/sync_allocate_overaligned_request.pass.cpp
index ce39a4fc6a0e..e15ffbc9776b 100644
--- a/libcxx/test/std/utilities/utility/mem.res/mem.res.pool/mem.res.pool.mem/sync_allocate_overaligned_request.pass.cpp
+++ b/libcxx/test/std/utilities/utility/mem.res/mem.res.pool/mem.res.pool.mem/sync_allocate_overaligned_request.pass.cpp
@@ -10,6 +10,9 @@
 // TODO: Change to XFAIL once https://llvm.org/PR40995 is fixed
 // UNSUPPORTED: availability-pmr-missing
 
+// Cygwin runtime has hack to able override operator-new defined in DLL from EXE but it don't works for align_val_t overloads.
+// XFAIL: cygwin
+
 // <memory_resource>
 
 // class synchronized_pool_resource
diff --git a/libcxx/test/std/utilities/utility/mem.res/mem.res.pool/mem.res.pool.mem/unsync_allocate_overaligned_request.pass.cpp b/libcxx/test/std/utilities/utility/mem.res/mem.res.pool/mem.res.pool.mem/unsync_allocate_overaligned_request.pass.cpp
index 82f75fb44344..c5de8fd18e6a 100644
--- a/libcxx/test/std/utilities/utility/mem.res/mem.res.pool/mem.res.pool.mem/unsync_allocate_overaligned_request.pass.cpp
+++ b/libcxx/test/std/utilities/utility/mem.res/mem.res.pool/mem.res.pool.mem/unsync_allocate_overaligned_request.pass.cpp
@@ -10,6 +10,9 @@
 // TODO: Change to XFAIL once https://llvm.org/PR40995 is fixed
 // UNSUPPORTED: availability-pmr-missing
 
+// Cygwin runtime has hack to able override operator-new defined in DLL from EXE but it don't works for align_val_t overloads.
+// XFAIL: cygwin
+
 // <memory_resource>
 
 // class unsynchronized_pool_resource
-- 
2.51.0

