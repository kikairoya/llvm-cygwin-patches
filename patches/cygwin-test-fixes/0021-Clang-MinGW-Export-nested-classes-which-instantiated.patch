From a01c6cfe4d9ca57ec0e8dd8b625ed7118163c35f Mon Sep 17 00:00:00 2001
From: kikairoya <kikairoya@gmail.com>
Date: Sun, 7 Sep 2025 22:31:20 +0900
Subject: [PATCH 21/56] [Clang][MinGW] Export nested classes which instantiated
 by enclosing template's explicit instantiation declaration

MinGW-GCC applies explicit instantiateion declaration of a class template to its nested type but doesn't inherit
`__declspec(dllexport)` attribute to the nested class, causes undefined reference to member functions of the nested
class.
To resolve this self-inconsistency, such `__declspec(dllexport)` attribute on explicit instantiation declaration should
inherit to the nested class.
---
 clang/lib/Sema/SemaDeclCXX.cpp | 15 +++++++++++++--
 1 file changed, 13 insertions(+), 2 deletions(-)

diff --git a/clang/lib/Sema/SemaDeclCXX.cpp b/clang/lib/Sema/SemaDeclCXX.cpp
index 2a1da7e0cdea8be073facdd20c246aad0d4fb3ec..9d9dc29cbed3a513fa11266cb406d4d511b60dfc 100644
--- a/clang/lib/Sema/SemaDeclCXX.cpp
+++ b/clang/lib/Sema/SemaDeclCXX.cpp
@@ -6590,11 +6590,13 @@ void Sema::checkClassLevelDLLAttribute(CXXRecordDecl *Class) {
       !ClassExported &&
       cast<DLLImportAttr>(ClassAttr)->wasPropagatedToBaseTemplate();
 
+  const TargetInfo &TI = Context.getTargetInfo();
+
   // Ignore explicit dllexport on explicit class template instantiation
   // declarations, except in MinGW mode.
   if (ClassExported && !ClassAttr->isInherited() &&
       TSK == TSK_ExplicitInstantiationDeclaration &&
-      !Context.getTargetInfo().getTriple().isOSCygMing()) {
+      !TI.getTriple().isOSCygMing()) {
     if (auto *DEA = Class->getAttr<DLLExportAttr>()) {
       Class->addAttr(DLLExportOnDeclAttr::Create(Context, DEA->getLoc()));
       Class->dropAttr<DLLExportAttr>();
@@ -6614,6 +6616,15 @@ void Sema::checkClassLevelDLLAttribute(CXXRecordDecl *Class) {
         Member->hasAttr<ExcludeFromExplicitInstantiationAttr>())
       continue;
 
+    // Inherit dllexport to nested class in MinGW mode.
+    if (TI.getTriple().isOSCygMing() && !getDLLAttr(Member) &&
+        isa<RecordDecl>(Member)) {
+      auto *NewAttr = cast<InheritableAttr>(ClassAttr->clone(getASTContext()));
+      NewAttr->setInherited(true);
+      Member->addAttr(NewAttr);
+      continue;
+    }
+
     VarDecl *VD = dyn_cast<VarDecl>(Member);
     CXXMethodDecl *MD = dyn_cast<CXXMethodDecl>(Member);
 
@@ -6629,7 +6640,7 @@ void Sema::checkClassLevelDLLAttribute(CXXRecordDecl *Class) {
       if (MD->isInlined()) {
         // MinGW does not import or export inline methods. But do it for
         // template instantiations.
-        if (!Context.getTargetInfo().shouldDLLImportComdatSymbols() &&
+        if (!TI.shouldDLLImportComdatSymbols() &&
             TSK != TSK_ExplicitInstantiationDeclaration &&
             TSK != TSK_ExplicitInstantiationDefinition)
           continue;
-- 
2.51.2

