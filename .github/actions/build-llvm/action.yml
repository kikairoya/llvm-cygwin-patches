name: Build LLVM
description: Build patched LLVM

inputs:
  llvm-path:
    description: Path to source tree
    required: true
  patch-path:
    description: Path to be used to clone patches
    required: true
  config-name:
    description: Build configuration name
    required: true
  cygwin-root:
    description: Cygwih root path
    reuqired: true
  build-project:
    description: Project root to build, relative to llvm-project
    required: true
  build-target:
    description: Target name to build, which is passed to ninja
    required: false
    default: ''
  build-name:
    description: Build name suffix
    required: true
  parallel-compile-jobs:
    description: LLVM_PARALLEL_COMPILE_JOBS
    required: false
  parallel-link-jobs:
    description: LLVM_PARALLEL_LINK_JOBS
    required: false
  extra-lit-opts:
    description: LIT_OPTS
    required: false
  install-prefix:
    description: PREFIX
    required: false
    default: '/'
  cmake-flags:
    description: CMake additional parameter
    required: false
  artifact-suffix:
    description: Additional suffix to artifact name
    required: false
    default: ''
  stage1-bindir:
    description: Prebuilt stage1 path
    required: false
    default: ''

outputs:
  build-name:
    description: Build identifier name
    value: ${{ inputs.build-project }}-${{ inputs.build-name }}
  build-artifact:
    description: ID of the uploaded build artifact
    value: ${{ steps.upload-build.outputs.artifact-id }}
  log-artifact:
    description: ID of the uploaded build-log artifact
    value: ${{ steps.upload-log.outputs.artifact-id }}
  install-artifact:
    description: ID of the uploaded install artifact
    value: ${{ steps.upload-install.outputs.artifact-id }}

runs:
  using: "composite"
  steps:
    - id: build
      name: build ${{ inputs.build-project }} ${{ inputs.config-name }}
      env:
        BUILD_NAME: ${{ inputs.build-name }}
        BUILD_TARGET: ${{ inputs.build-target }}
        CONFIG_NAME: ${{ inputs.config-name }}
        CYGWIN_ROOT: ${{ inputs.cygwin-root }}
        BUILD_PROJECT: ${{ inputs.build-project }}
        PARALLEL_COMPILE_JOBS: ${{ inputs.parallel-compile-jobs }}
        PARALLEL_LINK_JOBS: ${{ inputs.parallel-link-jobs }}
        LLVM_PATH: ${{ inputs.llvm-path }}
        PATCH_PATH: ${{ inputs.patch-path }}
        EXTRA_LIT_OPTS: ${{ inputs.extra-lit-opts }}
        CMAKE_FLAGS: ${{ inputs.cmake-flags }}
        STAGE1_BINDIR: ${{ inputs.stage1-bindir }}
      run: |
        ## Config, Build, Test
        if [ -d "$STAGE1_BINDIR" ]; then
          export PATH="$(realpath "$STAGE1_BINDIR"):$PATH"
        fi

        for b in build-*-$BUILD_NAME/bin; do
          if [ "$b" != "build-$BUILD_PROJECT-$BUILD_NAME/bin" ] && [ -d "$b" ]; then
            export PATH="$(realpath "$b"):$PATH"
          fi
        done

        if [ "$RUNNER_OS" == Windows ] && [ -n "$CYGWIN_ROOT" ]; then
          set +h
          pushd "$CYGWIN_ROOT" > /dev/null
          cd bin
          export PATH="$PWD:$PATH"
          popd > /dev/null
        fi

        if [[ $BUILD_TARGET = check* ]]; then
          pushd $PATCH_PATH/config/$CONFIG_NAME > /dev/null
            if [ -f xfail.txt ]; then
              export LIT_XFAIL="$(sed -e '2,$s#^#;#' xfail.txt | tr -d '\n')"
            fi
            if [ -f filter-out.txt ]; then
              export LIT_FILTER_OUT="($(sed -e '2,$s#^#)|(#' filter-out.txt | tr -d '\n'))"
            fi
            if [ -f filter.txt ]; then
              export LIT_FILTER="($(sed -e '2,$s#^#)|(#' filter.txt | tr -d '\n'))"
            fi
            if [ -f gtest_filter.txt ]; then
              export GTEST_FILTER="$(sed -e '1s#^#-#;2,$s#^#:#' gtest_filter.txt | tr -d '\n')"
            fi
          popd > /dev/null

          export LIT_OPTS="-sv --xunit-xml-output=$(realpath result-$BUILD_TARGET-$BUILD_PROJECT-$BUILD_NAME.xml) $EXTRA_LIT_OPTS"
          env | grep ^LIT_ > env-$BUILD_NAME.txt || true
          env | grep ^GTEST_ >> env-$BUILD_NAME.txt || true
        fi

        if ! [ -f build-$BUILD_PROJECT-$BUILD_NAME/CMakeCache.txt ]; then
          echo "::group::Configure"
          cmake -GNinja -Bbuild-$BUILD_PROJECT-$BUILD_NAME -S$LLVM_PATH/$BUILD_PROJECT -C$PATCH_PATH/config/$CONFIG_NAME/init.cmake | tee configlog-$BUILD_PROJECT-$BUILD_NAME.txt
          echo "::endgroup::"
        fi

        echo "::group::Build/Test"
        cmake --build build-$BUILD_PROJECT-$BUILD_NAME -- --quiet $BUILD_TARGET | tee buildlog-$BUILD_TARGET-$BUILD_PROJECT-$BUILD_NAME.txt
        echo "::endgroup::"
      shell: bash

    - id: archive
      if: ${{ always() }}
      name: archive ${{ inputs.build-project }} ${{ inputs.config-name }}
      env:
        BUILD_NAME: ${{ inputs.build-name }}
        BUILD_PROJECT: ${{ inputs.build-project }}
        CYGWIN_ROOT: ${{ inputs.cygwin-root }}
      run: |
        if [ "$RUNNER_OS" == Windows ] && [ -n "$CYGWIN_ROOT" ]; then
          set +h
          pushd "$CYGWIN_ROOT" > /dev/null
          cd bin
          export PATH=$PWD:$PATH
          popd > /dev/null
        fi

        tar caf build-$BUILD_PROJECT-$BUILD_NAME.tar build-$BUILD_PROJECT-$BUILD_NAME
      shell: bash

    - uses: actions/upload-artifact@v4
      if: ${{ always() }}
      id: upload-build
      with:
        name: build-artifact-${{ inputs.build-project }}-${{ inputs.build-target || 'all' }}-${{ inputs.config-name }}${{ inputs.artifact-suffix }}
        overwrite: true
        path: build-${{ inputs.build-project }}-${{ inputs.build-name }}.tar

    - uses: actions/upload-artifact@v4
      if: ${{ always() }}
      id: upload-log
      with:
        name: build-log-${{ inputs.build-project }}-${{ inputs.build-target || 'all' }}-${{ inputs.config-name }}${{ inputs.artifact-suffix }}
        overwrite: true
        path: |
          buildlog-*.txt
          configlog-*.txt
          env-*.txt
          result-*.xml

    - id: install
      if: ${{ inputs.install-prefix != '/' }}
      name: install ${{ inputs.build-project }} ${{ inputs.config-name }}
      env:
        BUILD_NAME: ${{ inputs.build-name }}
        BUILD_PROJECT: ${{ inputs.build-project }}
        INSTALL_PREFIX: ${{ inputs.install-prefix }}
        CYGWIN_ROOT: ${{ inputs.cygwin-root }}
      run: |
        if [ "$RUNNER_OS" == Windows ] && [ -n "$CYGWIN_ROOT" ]; then
          set +h
          pushd "$CYGWIN_ROOT" > /dev/null
          cd bin
          export PATH=$PWD:$PATH
          popd > /dev/null
        fi

        rm -f build-$BUILD_PROJECT-$BUILD_NAME.tar

        echo "::group::Install"
        cmake --install build-$BUILD_PROJECT-$BUILD_NAME --prefix install/$INSTALL_PREFIX
        echo "::endgroup::"

        cd install
        tar caf package-$BUILD_PROJECT-$BUILD_NAME.tar *
        mv package-$BUILD_PROJECT-$BUILD_NAME.tar ..
      shell: bash

    - uses: actions/upload-artifact@v4
      if: ${{ inputs.install-prefix != '/' }}
      id: upload-install
      with:
        name: package-${{ inputs.build-project }}-${{ inputs.config-name }}${{ inputs.artifact-suffix }}
        path: package-${{ inputs.build-project }}-${{ inputs.build-name }}.tar
