From a4e6abf67e072ee7cd0798ea1ddbaa6c22006f57 Mon Sep 17 00:00:00 2001
From: kikairoya <kikairoya@gmail.com>
Date: Sun, 2 Nov 2025 12:52:40 +0900
Subject: [PATCH 23/39] implement PE DLL support in abilist

---
 libcxx/utils/libcxx/sym_check/extract.py | 46 ++++++++++++++++++++++--
 libcxx/utils/libcxx/sym_check/util.py    |  8 ++++-
 2 files changed, 51 insertions(+), 3 deletions(-)

diff --git a/libcxx/utils/libcxx/sym_check/extract.py b/libcxx/utils/libcxx/sym_check/extract.py
index abd4abaa00018eab6197dc519fe6c32cdd16e2bd..19006fbd1fee514444de3913b2141ea83b4fd22f 100644
--- a/libcxx/utils/libcxx/sym_check/extract.py
+++ b/libcxx/utils/libcxx/sym_check/extract.py
@@ -194,6 +194,40 @@ class ReadElfExtractor(object):
         return lines[start:end]
 
 
+class LLVMReadObjDLLExtractor(object):
+    """
+    LLVMReadObjDLLExtractor - Extract symbol lists from PE DLL using llvm-readobj.
+    """
+
+    @staticmethod
+    def find_tool():
+        """
+        Search for the llvm-readobj executable and return the path.
+        """
+        return shutil.which("llvm-readobj")
+
+    def __init__(self, static_lib):
+        """
+        Initialize the llvm-readobj executable and flags that will be used to
+        extract symbols from shared libraries.
+        """
+        self.readobj_exe = self.find_tool()
+        if self.readobj_exe is None:
+            # ERROR no llvm-readobj found
+            print("ERROR: Could not find llvm-readobj")
+            sys.exit(1)
+
+    def extract(self, lib):
+        """
+        Extract symbols from a library and return the results as a dict of
+        parsed symbols.
+        """
+        r = re.compile(" *Name: *(.*)")
+        out = subprocess.check_output([self.readobj_exe, "--coff-exports", lib]).decode()
+        matches = (r.match(l) for l in out.splitlines())
+        return [{"name": m.group(1), "is_defined":True, "type": ""} for m in matches if m]
+
+
 class AIXDumpExtractor(object):
     """
     AIXDumpExtractor - Extract symbol lists from libraries using AIX dump.
@@ -287,17 +321,25 @@ def is_static_library(lib_file):
         _, ext = os.path.splitext(lib_file)
         return ext == ".a"
 
+def is_dll(lib_file):
+    """
+    Determine if a given library is a DLL file.
+    """
+    _, ext = os.path.splitext(lib_file)
+    return ext == ".dll"
 
 def extract_symbols(lib_file, static_lib=None):
     """
     Extract and return a list of symbols extracted from a static or dynamic
-    library. The symbols are extracted using dump, nm or readelf. They are
-    then filtered and formated. Finally the symbols are made unique.
+    library. The symbols are extracted using dump, llvm-readobj, nm, or readelf.
+    They are then filtered and formated. Finally the symbols are made unique.
     """
     if static_lib is None:
         static_lib = is_static_library(lib_file)
     if sys.platform.startswith("aix"):
         extractor = AIXDumpExtractor(static_lib=static_lib)
+    elif is_dll(lib_file):
+        extractor = LLVMReadObjDLLExtractor(static_lib=static_lib)
     elif ReadElfExtractor.find_tool() and not static_lib:
         extractor = ReadElfExtractor(static_lib=static_lib)
     else:
diff --git a/libcxx/utils/libcxx/sym_check/util.py b/libcxx/utils/libcxx/sym_check/util.py
index dbc886f29ddea3c2caf870f67a523ca6728fd1cb..65e9f0df9118c996be2f01b99de6be7cc4b0cdfc 100644
--- a/libcxx/utils/libcxx/sym_check/util.py
+++ b/libcxx/utils/libcxx/sym_check/util.py
@@ -78,6 +78,12 @@ def is_elf(filename):
     return magic_bytes == b"\x7fELF"
 
 
+def is_dll(filename):
+    with open(filename, "rb") as f:
+        magic_bytes = f.read(2)
+    return magic_bytes == b"MZ"
+
+
 def is_mach_o(filename):
     with open(filename, "rb") as f:
         magic_bytes = f.read(4)
@@ -106,7 +112,7 @@ def is_library_file(filename):
     elif sys.platform.startswith("aix"):
         return is_xcoff_or_big_ar(filename)
     else:
-        return is_elf(filename)
+        return is_elf(filename) or is_dll(filename)
 
 
 def extract_or_load(filename):
-- 
2.52.0

