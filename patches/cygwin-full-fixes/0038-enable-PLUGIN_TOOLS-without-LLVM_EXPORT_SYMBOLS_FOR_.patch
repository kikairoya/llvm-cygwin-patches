From eea91a53e86dcb6b68f68a10f1f4e43db30b1c6e Mon Sep 17 00:00:00 2001
From: kikairoya <kikairoya@gmail.com>
Date: Tue, 16 Dec 2025 01:30:15 +0900
Subject: [PATCH 38/54] enable PLUGIN_TOOLS without
 LLVM_EXPORT_SYMBOLS_FOR_PLUGIN

---
 llvm/cmake/modules/AddLLVM.cmake | 111 ++++++++++++++++++++-----------
 1 file changed, 72 insertions(+), 39 deletions(-)

diff --git a/llvm/cmake/modules/AddLLVM.cmake b/llvm/cmake/modules/AddLLVM.cmake
index 74aa9d6b62aff1b1166a7a2f8f4ad94e946d6265..87e7016c7e772cffc2304895075123b354f17e53 100644
--- a/llvm/cmake/modules/AddLLVM.cmake
+++ b/llvm/cmake/modules/AddLLVM.cmake
@@ -547,6 +547,13 @@ function(llvm_add_library name)
       message(STATUS "${name} ignored -- Loadable modules not supported on this platform.")
       return()
     endif()
+    if(ARG_PLUGIN_TOOL AND (WIN32 OR CYGWIN))
+      get_target_property(plugin_tool_exporting ${ARG_PLUGIN_TOOL} ENABLE_EXPORTS)
+      if(NOT plugin_tool_exporting)
+        message(WARNING "PLUGIN_TOOL for ${name} is ignored -- ${ARG_PLUGIN_TOOL} is not configured as a plugin target.")
+        set(ARG_PLUGIN_TOOL)
+      endif()
+    endif()
   else()
     if(ARG_PLUGIN_TOOL)
       message(WARNING "PLUGIN_TOOL without MODULE doesn't make sense.")
@@ -766,7 +773,7 @@ function(llvm_add_library name)
     set(libtype PRIVATE)
   endif()
 
-  if(ARG_MODULE AND LLVM_EXPORT_SYMBOLS_FOR_PLUGINS AND ARG_PLUGIN_TOOL AND (WIN32 OR CYGWIN))
+  if(ARG_MODULE AND ARG_PLUGIN_TOOL AND (WIN32 OR CYGWIN))
     # On DLL platforms symbols are imported from the tool by linking against it.
     set(llvm_libs ${ARG_PLUGIN_TOOL})
   elseif (NOT ARG_COMPONENT_LIB)
@@ -1349,6 +1356,56 @@ function(process_llvm_pass_plugins)
   endif()
 endfunction()
 
+function(list_static_nonstatic_libs_recursive target staticvar nonstaticvar)
+  # We need to consider not just the direct link dependencies, but also the
+  # transitive link dependencies. Do this by starting with the set of direct
+  # dependencies, then the dependencies of those dependencies, and so on.
+  get_target_property(new_libs ${target} LINK_LIBRARIES)
+  set(link_libs ${new_libs})
+  while(NOT "${new_libs}" STREQUAL "")
+    foreach(lib ${new_libs})
+      if(TARGET ${lib})
+        # If this is a ALIAS target, continue with its aliasee instead.
+        get_target_property(aliased_lib ${lib} ALIASED_TARGET)
+        if(aliased_lib)
+          set(new_libs ${lib_aliased_target})
+          list(APPEND newer_libs ${aliased_lib})
+          continue()
+        endif()
+
+        get_target_property(lib_type ${lib} TYPE)
+        if("${lib_type}" STREQUAL "STATIC_LIBRARY")
+          list(APPEND static_libs ${lib})
+        else()
+          list(APPEND other_libs ${lib})
+          get_target_property(transitive_libs ${lib} LINK_LIBRARIES)
+          foreach(transitive_lib ${transitive_libs})
+            if(TARGET ${transitive_lib} AND NOT ${transitive_lib} IN_LIST link_libs)
+              get_target_property(lib_type ${transitive_lib} TYPE)
+              if("${lib_type}" STREQUAL "SHARED_LIBRARY")
+                list(APPEND newer_libs ${transitive_lib})
+                list(APPEND link_libs ${transitive_lib})
+              endif()
+            endif()
+          endforeach(transitive_lib)
+        endif()
+        get_target_property(transitive_libs ${lib} INTERFACE_LINK_LIBRARIES)
+        foreach(transitive_lib ${transitive_libs})
+          if(TARGET ${transitive_lib} AND NOT ${transitive_lib} IN_LIST link_libs)
+            list(APPEND newer_libs ${transitive_lib})
+            list(APPEND link_libs ${transitive_lib})
+          endif()
+        endforeach(transitive_lib)
+      endif()
+    endforeach(lib)
+    set(new_libs ${newer_libs})
+    set(newer_libs "")
+  endwhile()
+  list(REMOVE_DUPLICATES static_libs)
+  set(${staticvar} "${static_libs}" PARENT_SCOPE)
+  set(${nonstaticvar} "${other_libs}" PARENT_SCOPE)
+endfunction()
+
 function(export_executable_symbols target)
   if (LLVM_EXPORTED_SYMBOL_FILE)
     # The symbol file should contain the symbols we want the executable to
@@ -1359,41 +1416,7 @@ function(export_executable_symbols target)
     # executable links against.
     set_target_properties(${target} PROPERTIES ENABLE_EXPORTS 1)
     set(exported_symbol_file ${CMAKE_CURRENT_BINARY_DIR}/${CMAKE_CFG_INTDIR}/${target}.symbols)
-    # We need to consider not just the direct link dependencies, but also the
-    # transitive link dependencies. Do this by starting with the set of direct
-    # dependencies, then the dependencies of those dependencies, and so on.
-    get_target_property(new_libs ${target} LINK_LIBRARIES)
-    set(link_libs ${new_libs})
-    while(NOT "${new_libs}" STREQUAL "")
-      foreach(lib ${new_libs})
-        if(TARGET ${lib})
-          # If this is a ALIAS target, continue with its aliasee instead.
-          get_target_property(aliased_lib ${lib} ALIASED_TARGET)
-          if(aliased_lib)
-             set(new_libs ${lib_aliased_target})
-             list(APPEND newer_libs ${aliased_lib})
-             continue()
-          endif()
-
-          get_target_property(lib_type ${lib} TYPE)
-          if("${lib_type}" STREQUAL "STATIC_LIBRARY")
-            list(APPEND static_libs ${lib})
-          else()
-            list(APPEND other_libs ${lib})
-          endif()
-          get_target_property(transitive_libs ${lib} INTERFACE_LINK_LIBRARIES)
-          foreach(transitive_lib ${transitive_libs})
-            if(TARGET ${transitive_lib} AND NOT ${transitive_lib} IN_LIST link_libs)
-              list(APPEND newer_libs ${transitive_lib})
-              list(APPEND link_libs ${transitive_lib})
-            endif()
-          endforeach(transitive_lib)
-        endif()
-      endforeach(lib)
-      set(new_libs ${newer_libs})
-      set(newer_libs "")
-    endwhile()
-    list(REMOVE_DUPLICATES static_libs)
+    list_static_nonstatic_libs_recursive(${target} static_libs other_libs)
     if (MSVC)
       set(mangling microsoft)
     else()
@@ -1418,10 +1441,20 @@ function(export_executable_symbols target)
     # transitive link against only the libraries whose symbols
     # we aren't exporting.
     set_target_properties(${target} PROPERTIES INTERFACE_LINK_LIBRARIES "${other_libs}")
-  elseif(NOT (WIN32 OR CYGWIN))
+  elseif(WIN32 OR CYGWIN)
     # On Windows auto-exporting everything doesn't work because of the limit on
-    # the size of the exported symbol table, but on other platforms we can do
-    # it without any trouble.
+    # the size of the exported symbol table.
+    # If the executable links to DLLs, we can reuse them to link with plugins.
+    # For the case of static linking, LLVM_EXPORT_SYMBOLS_FOR_PLUGINS is needed
+    # explicitly (be careful to 64k limits). Otherwise, an use of PLUGIN_TOOL
+    # will emit a warning.
+    if(BUILD_SHARED_LIBS OR LLVM_LINK_LLVM_DYLIB)
+      set_target_properties(${target} PROPERTIES ENABLE_EXPORTS 1)
+      list_static_nonstatic_libs_recursive(${target} static_libs other_libs)
+      set_target_properties(${target} PROPERTIES INTERFACE_LINK_LIBRARIES "${other_libs}")
+    endif()
+  else()
+    # On non-Windows platforms, we can export everything without any trouble.
     set_target_properties(${target} PROPERTIES ENABLE_EXPORTS 1)
     # CMake doesn't set CMAKE_EXE_EXPORTS_${lang}_FLAG on Solaris, so
     # ENABLE_EXPORTS has no effect.  While Solaris ld defaults to -rdynamic
-- 
2.52.0

