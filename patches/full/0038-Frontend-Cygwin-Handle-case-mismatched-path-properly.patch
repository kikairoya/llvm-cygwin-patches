From f78ba84c44e4e8794979ac7f75d7dea319144d6b Mon Sep 17 00:00:00 2001
From: kikairoya <kikairoya@gmail.com>
Date: Fri, 2 May 2025 23:16:55 +0900
Subject: [PATCH 38/38] [Frontend][Cygwin] Handle case-mismatched path properly
 on cygwin

`realpath` provided by cygwin1.dll does not return real-name: that
resolves symlink and cygwin-mountpoint but not case-mismatch.
So to detect case-mismatched `#include`, need to dedicated workaround
using Win32API.
---
 clang/lib/Frontend/DependencyFile.cpp |  2 +-
 llvm/lib/Support/Unix/Path.inc        | 37 ++++++++++++++++++++++++++-
 2 files changed, 37 insertions(+), 2 deletions(-)

diff --git a/clang/lib/Frontend/DependencyFile.cpp b/clang/lib/Frontend/DependencyFile.cpp
index 15fa7de35df9..7825f0a0b6d0 100644
--- a/clang/lib/Frontend/DependencyFile.cpp
+++ b/clang/lib/Frontend/DependencyFile.cpp
@@ -177,7 +177,7 @@ void DependencyCollector::maybeAddDependency(StringRef Filename,
 
 bool DependencyCollector::addDependency(StringRef Filename) {
   StringRef SearchPath;
-#ifdef _WIN32
+#if defined(_WIN32) || defined(__CYGWIN__)
   // Make the search insensitive to case and separators.
   llvm::SmallString<256> TmpPath = Filename;
   llvm::sys::path::native(TmpPath);
diff --git a/llvm/lib/Support/Unix/Path.inc b/llvm/lib/Support/Unix/Path.inc
index 0d991ead7241..71184c9f4079 100644
--- a/llvm/lib/Support/Unix/Path.inc
+++ b/llvm/lib/Support/Unix/Path.inc
@@ -52,6 +52,12 @@ extern char **environ;
 #include <sys/ps.h>
 #endif
 
+#if defined(__CYGWIN__)
+#include <io.h>
+#include <sys/cygwin.h>
+#include <windows.h>
+#endif
+
 // Both stdio.h and cstdio are included via different paths and
 // stdcxx's cstdio doesn't include stdio.h, so it doesn't #undef the macros
 // either.
@@ -972,7 +978,7 @@ ErrorOr<basic_file_status> directory_entry::status() const {
 #define TRY_PROC_SELF_FD
 #endif
 
-#if !defined(F_GETPATH) && defined(TRY_PROC_SELF_FD)
+#if !defined(F_GETPATH) && defined(TRY_PROC_SELF_FD) && !defined(__CYGWIN__)
 static bool hasProcSelfFD() {
   // If we have a /proc filesystem mounted, we can quickly establish the
   // real name of the file with readlink
@@ -1151,6 +1157,8 @@ std::error_code openFileForRead(const Twine &Name, int &ResultFD,
   if (!RealPath)
     return std::error_code();
   RealPath->clear();
+  // ::realpath on Cygwin does not canonicalise case, so use Win32API
+#if !defined(__CYGWIN__)
 #if defined(F_GETPATH)
   // When F_GETPATH is availble, it is the quickest way to get
   // the real path name.
@@ -1177,6 +1185,33 @@ std::error_code openFileForRead(const Twine &Name, int &ResultFD,
 #if defined(TRY_PROC_SELF_FD)
   }
 #endif
+#endif
+#else
+  // FIXME: this block is copied from Windows/Path.inc, but pathes of Win32
+  //        may be longer than PATH_MAX.
+  SmallVector<wchar_t, PATH_MAX> BufferW;
+  BufferW.resize_for_overwrite(BufferW.capacity());
+  const auto H = reinterpret_cast<HANDLE>(::_get_osfhandle(ResultFD));
+  ssize_t CountChars = ::GetFinalPathNameByHandleW(
+      H, BufferW.begin(), BufferW.capacity(), FILE_NAME_NORMALIZED);
+  if (CountChars > 0 && (size_t)CountChars >= BufferW.capacity()) {
+    BufferW.resize_for_overwrite(CountChars);
+    CountChars = ::GetFinalPathNameByHandleW(H, BufferW.begin(), BufferW.size(),
+                                             FILE_NAME_NORMALIZED);
+  }
+  if (CountChars > 0) {
+    BufferW.truncate(CountChars);
+    CountChars =
+        ::cygwin_conv_path(CCP_WIN_W_TO_POSIX, BufferW.begin(), nullptr, 0);
+    if (CountChars > 0) {
+      RealPath->resize_for_overwrite(CountChars);
+      if (::cygwin_conv_path(CCP_WIN_W_TO_POSIX, BufferW.begin(),
+                             RealPath->begin(), RealPath->size()) < 0)
+        RealPath->clear();
+      else
+        RealPath->truncate(RealPath->size() - 1);
+    }
+  }
 #endif
   return std::error_code();
 }
-- 
2.51.1

