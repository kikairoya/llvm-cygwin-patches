From 0cac80b20aa0677b218a518959728c0dc14aa3d9 Mon Sep 17 00:00:00 2001
From: kikairoya <kikairoya@gmail.com>
Date: Wed, 17 Dec 2025 19:02:44 +0900
Subject: [PATCH 28/55] [LLVM] Support EXPORT_SYMBOLS_FOR_PLUGINS with shared
 or dylib builds

Resolve the incompatibilities of EXPORT_SYMBOLS_FOR_PLUGINS with
`-DBUILD_SHARED_LIBS=ON` or `-DLLVM_LINK_LLVM_DYLIB=ON`:

- Static libraries linked to the target may be empty:
  Added a checking if the target link any static libraries.
- `export_executable_symbols` may run before target's dependencies are fully registered:
  Defer scanning the target's dependencies to just before finishing CMaking.
---
 llvm/cmake/modules/AddLLVM.cmake | 114 ++++++++++++++++++-------------
 1 file changed, 65 insertions(+), 49 deletions(-)

diff --git a/llvm/cmake/modules/AddLLVM.cmake b/llvm/cmake/modules/AddLLVM.cmake
index 8d1e47089348a1125cf3c2d83fe95172929f1696..df2a1092c9c5e505c57a6db1c02ad98738ff8cf7 100644
--- a/llvm/cmake/modules/AddLLVM.cmake
+++ b/llvm/cmake/modules/AddLLVM.cmake
@@ -1315,52 +1315,44 @@ function(process_llvm_pass_plugins)
   endif()
 endfunction()
 
-function(export_executable_symbols target)
-  if (LLVM_EXPORTED_SYMBOL_FILE)
-    # The symbol file should contain the symbols we want the executable to
-    # export
-    set_target_properties(${target} PROPERTIES ENABLE_EXPORTS 1)
-  elseif (LLVM_EXPORT_SYMBOLS_FOR_PLUGINS)
-    # Extract the symbols to export from the static libraries that the
-    # executable links against.
-    set_target_properties(${target} PROPERTIES ENABLE_EXPORTS 1)
-    set(exported_symbol_file ${CMAKE_CURRENT_BINARY_DIR}/${CMAKE_CFG_INTDIR}/${target}.symbols)
-    # We need to consider not just the direct link dependencies, but also the
-    # transitive link dependencies. Do this by starting with the set of direct
-    # dependencies, then the dependencies of those dependencies, and so on.
-    get_target_property(new_libs ${target} LINK_LIBRARIES)
-    set(link_libs ${new_libs})
-    while(NOT "${new_libs}" STREQUAL "")
-      foreach(lib ${new_libs})
-        if(TARGET ${lib})
-          # If this is a ALIAS target, continue with its aliasee instead.
-          get_target_property(aliased_lib ${lib} ALIASED_TARGET)
-          if(aliased_lib)
-             set(new_libs ${lib_aliased_target})
-             list(APPEND newer_libs ${aliased_lib})
-             continue()
-          endif()
+function(do_export_executable_symbols_for_plugins target exported_symbol_file)
+  # We need to consider not just the direct link dependencies, but also the
+  # transitive link dependencies. Do this by starting with the set of direct
+  # dependencies, then the dependencies of those dependencies, and so on.
+  get_target_property(new_libs ${target} LINK_LIBRARIES)
+  set(link_libs ${new_libs})
+  while(NOT "${new_libs}" STREQUAL "")
+    foreach(lib ${new_libs})
+      if(TARGET ${lib})
+        # If this is a ALIAS target, continue with its aliasee instead.
+        get_target_property(aliased_lib ${lib} ALIASED_TARGET)
+        if(aliased_lib)
+          set(new_libs ${lib_aliased_target})
+          list(APPEND newer_libs ${aliased_lib})
+          continue()
+        endif()
 
-          get_target_property(lib_type ${lib} TYPE)
-          if("${lib_type}" STREQUAL "STATIC_LIBRARY")
-            list(APPEND static_libs ${lib})
-          else()
-            list(APPEND other_libs ${lib})
-          endif()
-          get_target_property(transitive_libs ${lib} INTERFACE_LINK_LIBRARIES)
-          foreach(transitive_lib ${transitive_libs})
-            if(TARGET ${transitive_lib} AND NOT ${transitive_lib} IN_LIST link_libs)
-              list(APPEND newer_libs ${transitive_lib})
-              list(APPEND link_libs ${transitive_lib})
-            endif()
-          endforeach(transitive_lib)
+        get_target_property(lib_type ${lib} TYPE)
+        if("${lib_type}" STREQUAL "STATIC_LIBRARY")
+          list(APPEND static_libs ${lib})
+        else()
+          list(APPEND other_libs ${lib})
         endif()
-      endforeach(lib)
-      set(new_libs ${newer_libs})
-      set(newer_libs "")
-    endwhile()
-    list(REMOVE_DUPLICATES static_libs)
-    if (MSVC)
+        get_target_property(transitive_libs ${lib} INTERFACE_LINK_LIBRARIES)
+        foreach(transitive_lib ${transitive_libs})
+          if(TARGET ${transitive_lib} AND NOT ${transitive_lib} IN_LIST link_libs)
+            list(APPEND newer_libs ${transitive_lib})
+            list(APPEND link_libs ${transitive_lib})
+          endif()
+        endforeach(transitive_lib)
+      endif()
+    endforeach(lib)
+    set(new_libs ${newer_libs})
+    set(newer_libs "")
+  endwhile()
+  list(REMOVE_DUPLICATES static_libs)
+  if(static_libs)
+    if (MSVC OR CMAKE_CXX_SIMULATE_ID STREQUAL "MSVC")
       set(mangling microsoft)
     else()
       set(mangling itanium)
@@ -1379,11 +1371,35 @@ function(export_executable_symbols target)
                          ${static_libs} ${llvm_nm_target} ${llvm_readobj_target}
                        VERBATIM
                        COMMENT "Generating export list for ${target}")
-    add_llvm_symbol_exports( ${target} ${exported_symbol_file} )
-    # If something links against this executable then we want a
-    # transitive link against only the libraries whose symbols
-    # we aren't exporting.
-    set_target_properties(${target} PROPERTIES INTERFACE_LINK_LIBRARIES "${other_libs}")
+  else()
+    # When shared or dylib builds, static_libs can be empty.
+    file(GENERATE OUTPUT ${exported_symbol_file} CONTENT "")
+  endif()
+  add_llvm_symbol_exports( ${target} ${exported_symbol_file} )
+  # If something links against this executable then we want a
+  # transitive link against only the libraries whose symbols
+  # we aren't exporting.
+  set_target_properties(${target} PROPERTIES INTERFACE_LINK_LIBRARIES "${other_libs}")
+endfunction()
+
+function(export_executable_symbols target)
+  if (LLVM_EXPORTED_SYMBOL_FILE)
+    # The symbol file should contain the symbols we want the executable to
+    # export
+    set_target_properties(${target} PROPERTIES ENABLE_EXPORTS 1)
+  elseif (LLVM_EXPORT_SYMBOLS_FOR_PLUGINS)
+    # Extract the symbols to export from the static libraries that the
+    # executable links against.
+    set_target_properties(${target} PROPERTIES ENABLE_EXPORTS 1)
+    set(exported_symbol_file ${CMAKE_CURRENT_BINARY_DIR}/${CMAKE_CFG_INTDIR}/${target}.symbols)
+    # Defer the actual process of exporting since dependants might not
+    # registered yet; e.g. exporting from `clang` is called before
+    # `clang-cpp`(clang-shlib) is registered.
+    cmake_language(EVAL CODE "
+      cmake_language(DEFER DIRECTORY ${CMAKE_SOURCE_DIR}
+        CALL do_export_executable_symbols_for_plugins [[${target}]] [[${exported_symbol_file}]]
+      )
+    ")
   elseif(NOT (WIN32 OR CYGWIN))
     # On Windows auto-exporting everything doesn't work because of the limit on
     # the size of the exported symbol table, but on other platforms we can do
-- 
2.52.0

